{"version":3,"sources":["apis/nftsApi.ts","apis/orderApi.ts","apis/tokenPaymentApi.ts","redux/actions/tokenPaymentAction.ts","apis/historyApi.ts","redux/actions/tradingAction.ts","redux/actions/nftItemByItemIdAction.ts","redux/actions/orderAction.ts","pages/ItemDetail/index.tsx"],"names":["nftsApi","createNft","data","chainId","axiosAuthen","post","updateNftByItemId","userAddress","itemId","url","put","freezeNft","metaData","body","getListTokenId","paginationParams","filter","pageSize","page","axiosClient","getSearchListTokenId","getLessNftInfoByTokenId","get","getDetailNftItemById","getSearchNftItemById","getDataForFreezeNft","orderApi","createOrder","console","log","acceptOrder","order","collectionId","transactionHash","type","finalPrice","deleteOrder","getOrderDetailByUser","orderId","getOrderDetail","getOrderSellByItemId","getPersonalOffer","getListOffer","tokenPaymentApi","getListPaymentTokenByChainId","changeTokenToUsd","from","to","inputPrice","fetchListPaymentTokenByChainId","MyCallBack","a","dispatch","startLoading","response","fetchListTokenPaymentSuccess","hasError","getState","tradingApi","getTradingHistoryByNFTsId","getActivityHistoryByUserAddress","getActivityHistoryByCollectionId","getActivityPriceChart","getLatestTransaction","fetchTradingHistoryByNFTsId","fetchTradingHistorySuccess","fetchUserHistory","fetchUserHistorySuccess","fetchCollectionHistory","fetchCollectionHistorySuccess","fetchDetailNftItemById","fetchNftItemSuccess","fetchListOrderOffer","getListOrderOfferSuccess","TradingHistory","Loadable","lazy","ItemImage","MoreItem","TabItemDetail","Loading","Detail","useParams","useDispatch","useState","listActivityPriceChart","setListActivityPriceChart","personalOffer","setPersonalOffer","isLoadingPersonalOffer","setIsLoadingPersonalOffer","isDeletingOrderExpired","setIsDeletingOrderExpired","stateRefetchApi","setStateRefetchApi","item","useSelector","selectNftItem","selectChainId","isLoadingItem","selectLoading","selectFilter","addressState","selectAddress","useEffect","executeAfterFetchNftItemById","window","scrollTo","top","behavior","executeAfterFetchListTokenPayment","executeAfterFetchListOrderOffer","offerRes","message","historyApi","executeAfterFetchHistoryOfItem","refetchApi","globalStateNewest","nftItem","isSuccess","toast","error","errorMessage","autoClose","orderSell","NFTItem","compareDate","Date","timestampToDate","parseInt","expirationTime","collection","deleteData","_id","ORDER_TYPE","EXPIRED_LISTING","tokenPayment","tradeHistory","maxWidth","sx","mt","container","spacing","xs","lg","loadingPersonalOffer"],"mappings":"mLAIMA,EAAU,CAEfC,UAFe,SAELC,EAA+BC,GAExC,OAAOC,IAAYC,KADV,gBACoBH,IAE9BI,kBANe,SAOdJ,EACAK,EACAC,GAEA,IAAMC,EAAG,oCAAgCF,EAAhC,mBAAsDC,GAC/D,OAAOJ,IAAYM,IAAID,EAAKP,IAE7BS,UAde,SAcLH,EAAgBD,EAAqBK,GAC9C,IAEMC,EAAO,CAAEL,SAAQD,cAAaK,YACpC,OAAOR,IAAYM,IAHV,gBAGmBG,IAI7BC,eAtBe,SAsBAC,EAA8BC,GAC5C,IAAQC,EAAmBF,EAAnBE,SAAUC,EAASH,EAATG,KAEZT,EAAG,gCAA4BQ,EAA5B,iBAA6CC,GAChDL,EAAI,eAAQG,GAClB,OAAOG,IAAYd,KAAKI,EAAKI,IAE9BO,qBA7Be,SA6BML,EAA8BC,GAClD,IAAQC,EAAmBF,EAAnBE,SAAUC,EAASH,EAATG,KAEZT,EAAG,uCAAmCQ,EAAnC,iBAAoDC,GACvDL,EAAI,eAAQG,GAClB,OAAOG,IAAYd,KAAKI,EAAKI,IAE9BQ,wBApCe,SAoCSL,GACvB,IAAQR,EAAwBQ,EAAxBR,OAAQD,EAAgBS,EAAhBT,YACVE,EAAG,wBAAoBD,EAApB,wBAA0CD,GACnD,OAAOY,IAAYG,IAAIb,IAExBc,qBAzCe,SAyCMf,GACpB,IAAMC,EAAG,+BAA2BD,GACpC,OAAOW,IAAYG,IAAIb,IAExBe,qBA7Ce,SA6CMhB,GACpB,IAAMC,EAAG,+BAA2BD,GACpC,OAAOW,IAAYG,IAAIb,IAExBgB,oBAjDe,SAiDKjB,GACnB,IAAMC,EAAG,wCAAoCD,GAC7C,OAAOW,IAAYG,IAAIb,KAIVT,O,+DCvDT0B,EAAW,CAEhBC,YAFgB,SAEJzB,EAAWC,GACtByB,QAAQC,IAAI,kBAAZ,2BAAoC3B,GAApC,IAA0CC,aAG1C,OAAOC,IAAYC,KADV,eACF,2BAA2BH,GAA3B,IAAiCC,cAEzC2B,YARgB,SAQJ5B,GACX,IAAQ6B,EACP7B,EADO6B,MAAOC,EACd9B,EADc8B,aAAc7B,EAC5BD,EAD4BC,QAAS8B,EACrC/B,EADqC+B,gBAAiBC,EACtDhC,EADsDgC,KAAMC,EAC5DjC,EAD4DiC,WAAY5B,EACxEL,EADwEK,YAazE,OAVAqB,QAAQC,IAAI,kBAAZ,2BACIE,GADJ,IAECC,eACAC,kBACAC,OACAC,aACA5B,cACAJ,aAGMC,IAAYC,KAXV,aAWF,2BACH0B,GADG,IAENC,eACAC,kBACAC,OACAC,aACA5B,cACAJ,cAIFiC,YAjCgB,SAiCJlC,GACX0B,QAAQC,IAAI,kBAAmB3B,GAG/B,OAAOE,IAAYC,KADV,gBACoBH,IAI9BmC,qBAzCgB,SAyCKC,GACpB,IAAM7B,EAAG,+BAA2B6B,GACpC,OAAOnB,IAAYG,IAAIb,IAGxB8B,eA9CgB,SA8CDD,GACd,IAAM7B,EAAG,iCAA6B6B,GACtC,OAAOnB,IAAYG,IAAIb,IAGxB+B,qBAnDgB,SAmDKhC,GACpB,IAAMC,EAAG,wBAAoBD,GAC7B,OAAOW,IAAYG,IAAIb,IAGxBgC,iBAxDgB,SAwDClC,EAAqBC,GACrC,IAAMC,EAAG,6BAAyBF,EAAzB,mBAA+CC,GACxD,OAAOW,IAAYG,IAAIb,IAGxBiC,aA7DgB,SA6DH1B,GAEZ,OAAOG,IAAYd,KADV,eACoBW,KAIhBU,O,kCCvEf,aAEMiB,EAAkB,CACvBC,6BADuB,SACMzC,GAC5B,IAAMM,EAAG,mCAA+BN,GACxC,OAAOgB,IAAYG,IAAIb,IAGxBoC,iBANuB,SAMNC,EAAcC,EAAYC,GAE1C,OAAO7B,IAAYd,KADV,qBACoB,CAAEyC,OAAMC,KAAIC,iBAI5BL,O,2HCJR,SAASM,EAA+B9C,EAAiB+C,GAC/D,6BAAO,4BAAAC,EAAA,6DACNC,YAASC,eADH,kBAIEV,IAAgBC,6BAA6BzC,GAJ/C,OAGCmD,EAHD,OAKLF,YAASG,YAA6BD,IALjC,gDAOLF,YAASI,YAAS,EAAD,KACbN,GAAYA,EAAWO,eARtB,2D,kCCVR,aAEMC,EAAa,CAClBC,0BADkB,SACQzD,GACzB,IAAQM,EAAWN,EAAXM,OACFC,EAAG,4BAAwBD,EAAxB,yBACT,OAAOW,IAAYG,IAAIb,IAExBmD,gCANkB,SAMcrD,GAC/B,IAAME,EAAG,iCAA6BF,EAA7B,yBACT,OAAOY,IAAYG,IAAIb,IAExBoD,iCAVkB,SAWjB7B,GAEA,IAAMvB,EAAG,kCAA8BuB,EAA9B,yBACT,OAAOb,IAAYG,IAAIb,IAExBqD,sBAhBkB,SAgBItD,GACrB,IAAMC,EAAG,kCAA8BD,GACvC,OAAOW,IAAYG,IAAIb,IAExBsD,qBApBkB,WAsBjB,OAAO5C,IAAYG,IADV,uBAKIoC,O,+LCjBR,SAASM,EAA4B9D,EAAkBgD,GAC7D,6BAAO,4BAAAC,EAAA,6DACNC,YAASC,eADH,kBAGkCK,IAAWC,0BAA0BzD,GAHvE,OAGCoD,EAHD,OAKLF,YAASa,YAA2BX,IAL/B,gDAOLF,YAASI,YAAS,EAAD,KAPZ,yBASDN,GAAYA,EAAWO,eATtB,4EAcD,SAASS,EAAiB3D,EAAqB2C,GACrD,6BAAO,4BAAAC,EAAA,6DACNC,YAASC,eADH,kBAGkBK,IAAWE,gCAAgCrD,GAH7D,OAGC+C,EAHD,OAILF,YAASe,YAAwBb,IAJ5B,gDAMLF,YAASI,YAAS,EAAD,KANZ,yBAQDN,GAAYA,EAAWO,eARtB,4EAaD,SAASW,EAAuBpC,EAAsBkB,GAC5D,6BAAO,4BAAAC,EAAA,6DACNC,YAASC,eADH,kBAGkBK,IAAWG,iCAAiC7B,GAH9D,OAGCsB,EAHD,OAILF,YAASiB,YAA8Bf,IAJlC,gDAMLF,YAASI,YAAS,EAAD,KANZ,yBAQDN,GAAYA,EAAWO,eARtB,8E,mHCtCD,SAASa,EAAuB9D,EAAgB0C,GACtD,8CAAO,WAAOE,EAAeK,GAAtB,eAAAN,EAAA,6DACNC,EAASC,eADH,kBAGiCrD,IAAQuB,qBAAqBf,GAH9D,OAGC8C,EAHD,OAILF,EAASmB,YAAoBjB,IAJxB,gDAMLF,EAASI,YAAS,EAAD,KANZ,yBAQDN,GAAYA,EAAWO,KARtB,4EAAP,0D,2HCAM,SAASe,EAAoBxD,EAAoBkC,GACvD,6BAAO,4BAAAC,EAAA,6DACNC,YAASC,eADH,kBAGkD3B,IAASgB,aAAa1B,GAHxE,OAGCsC,EAHD,OAKLF,YAASqB,YAAyBnB,IAL7B,gDAOLF,YAASI,YAAS,EAAD,KAPZ,yBASDN,GAAYA,EAAWO,eATtB,8E,wQCyBFiB,EAAiBC,YAASC,gBAAK,kBAAM,oCACrCC,EAAYF,YAASC,gBAAK,kBAAM,0DAChCE,EAAWH,YAASC,gBAAK,kBAAM,iEAC/BG,EAAgBJ,YAASC,gBAAK,kBAAM,oCACpCI,EAAUL,YAASC,gBAAK,kBAAM,6CAuMrBK,UAnMA,WACd,IAAQzE,EAAW0E,cAAX1E,OACF4C,EAAW+B,cAGjB,EAA4DC,mBAA0B,IAAtF,mBAAOC,EAAP,KAA+BC,EAA/B,KACA,EAA0CF,mBAAkC,MAA5E,mBAAOG,EAAP,KAAsBC,EAAtB,KACA,EAA4DJ,oBAAkB,GAA9E,mBAAOK,EAAP,KAA+BC,EAA/B,KACA,EAA4DN,oBAAkB,GAA9E,mBAAOO,EAAP,KAA+BC,EAA/B,KACA,EAA8CR,oBAAkB,GAAhE,mBAAOS,EAAP,KAAwBC,EAAxB,KAGMC,EAAmBC,YAAYC,KAC/B9F,EAAU6F,YAAYE,KACtBC,EAAgBH,YAAYI,KAC5BpF,EAASgF,YAAYK,KACrBC,GAAeN,YAAYO,KAIjCC,qBAAU,WACLhG,GAAQ4C,EAASkB,YAAuB9D,EAAQiG,KAEpDC,OAAOC,SAAS,CAAEC,IAAK,EAAGC,SAAU,aAElC,CAAChB,EAAiBrF,IAGrBgG,qBAAU,WACLrG,GACHiD,EAASH,YAA+B9C,EAAS2G,OAGhD,CAAC3G,IAGJqG,qBAAU,WACLrG,GAAWK,GACd4C,EAASoB,YAAoB,aAAEhE,UAAWQ,GAAU+F,OAEnD,CAAC3D,EAAUjD,EAASa,EAAQ6E,EAAiBrF,IAGhDgG,qBAAU,WACLF,IAAgB9F,GACnB,sBAAC,4BAAA2C,EAAA,sEAECuC,GAA0B,GAF3B,SAG0ChE,IAASe,iBACjD6D,GACA9F,GALF,OAGOwG,EAHP,OAQCxB,EAAiBwB,GARlB,gDAUCxB,EAAiB,MACjB5D,QAAQC,IAAI,KAAMoF,SAXnB,yBAaCvB,GAA0B,GAb3B,2EAAD,KAiBC,CAACY,GAAc9F,EAAQqF,IAG1BW,qBAAU,WACLhG,GACH,sBAAC,4BAAA2C,EAAA,+EAEyC+D,IAAWpD,sBAClDtD,GAHF,OAEO8C,EAFP,OAMCgC,EAA0BhC,GAN3B,gDAQC1B,QAAQC,IAAR,MARD,wDAAD,KAYC,CAACuB,EAAUyC,EAAiBrF,IAG/BgG,qBAAU,WACLrG,GACHiD,EACCY,YAA4B,CAAE7D,UAASK,UAAU2G,OAGjD,CAAC/D,EAAU5C,EAAQL,EAAS0F,EAAiBrF,IAGhD,IAAM4G,GAAa,WAClBtB,GAAoBD,IAGfY,GAA4B,uCAAG,WAAOY,GAAP,yBAAAlE,EAAA,0DAC5BmE,EAAYD,EAAZC,SAEKC,UAHuB,uBAInCC,IAAMC,MAAMH,EAAQI,aAAc,CACjCC,UAAW,OALuB,gCAW9BC,EAA0CN,EAAQO,QAAS9F,QAGhE+F,YAAY,IAAIC,KAAQC,YAAgBC,SAASL,EAAUM,kBAAoB,GAd5C,iCAiBlCtC,GAA0B,GAEpB5D,EAnB4B,UAmBbsF,EAAQO,QAASM,kBAnBJ,aAmBb,EAA6BnG,aAE5CoG,EAAa,CAClBpG,eACAM,QAAO,UAAEsF,EAAUtF,eAAZ,QAAuBsF,EAAUS,IACxCnG,KAAMoG,IAAWC,gBACjBtG,gBAAiB,IAzBgB,UA4B5BP,IAASU,YAAYgG,GA5BO,QA8BlChB,KA9BkC,kDAgClCI,IAAMC,MAAM,4DAhCsB,yBAkClC7B,GAA0B,GAlCQ,6EAAH,sDAuC5BkB,GAAoC,SAACO,GACjBA,EAAjBmB,aACUjB,WACjBC,IAAMC,MAAM,sCAIRV,GAAkC,SAACM,GACtBA,EAAVtF,MACGwF,WACVC,IAAMC,MAAM,4CAIRN,GAAiC,SAACE,GACdA,EAAjBoB,aACUlB,WACjBC,IAAMC,MAAM,0CAId,OACC,mCACEtB,GAAiBR,EACjB,cAACX,EAAD,IAEA,eAAC,IAAD,CAAW0D,SAAS,KAAKC,GAAI,CAAEC,GAAI,GAAnC,UACC,eAAC,IAAD,CAAMC,WAAS,EAACC,QAAS,GAAzB,UACC,cAAC,IAAD,CAAM/C,MAAI,EAACgD,GAAI,GAAIC,GAAI,EAAvB,SACC,cAACnE,EAAD,CAAWkB,KAAMA,MAElB,cAAC,IAAD,CAAMA,MAAI,EAACgD,GAAI,GAAIC,GAAI,EAAvB,SACC,cAACjE,EAAD,CAECgB,KAAMA,EACNR,cAAeA,EACf0D,qBAAsBxD,EACtB2B,WAAYA,GAEZ/B,uBAAwBA,SAK1BU,GACA,cAAC,IAAD,CAAK4C,GAAI,CAAEC,GAAI,GAAf,SACC,cAAClE,EAAD,MAIDlE,GACA,cAAC,IAAD,CAAKmI,GAAI,CAAEC,GAAI,GAAf,SACC,cAAC9D,EAAD,CAAUqD,WAAU,OAAEpC,QAAF,IAAEA,OAAF,EAAEA,EAAMoC,WAAY3H,OAAQA","file":"static/js/37.3e22ce8c.chunk.js","sourcesContent":["import { ListParams, CreateAndUpdateNFTInput } from 'models';\nimport axiosAuthen from './axiosAuthen';\nimport axiosClient from './axiosClient';\n\nconst nftsApi = {\n\t//AUTHENTICATE\n\tcreateNft(data: CreateAndUpdateNFTInput, chainId: number): Promise<any> {\n\t\tconst url = `/items/create`;\n\t\treturn axiosAuthen.post(url, data);\n\t},\n\tupdateNftByItemId(\n\t\tdata: CreateAndUpdateNFTInput,\n\t\tuserAddress: string,\n\t\titemId: string\n\t): Promise<any> {\n\t\tconst url = `/items/update/userAddress/${userAddress}/itemId/${itemId}`;\n\t\treturn axiosAuthen.put(url, data);\n\t},\n\tfreezeNft(itemId: string, userAddress: string, metaData: string): Promise<any> {\n\t\tconst url = `/items/freeze`;\n\n\t\tconst body = { itemId, userAddress, metaData };\n\t\treturn axiosAuthen.put(url, body);\n\t},\n\n\t//CLIENT\n\tgetListTokenId(paginationParams: ListParams, filter: ListParams): Promise<any> {\n\t\tconst { pageSize, page } = paginationParams;\n\n\t\tconst url = `/items/query/pageSize/${pageSize}/page/${page}`;\n\t\tconst body = { ...filter };\n\t\treturn axiosClient.post(url, body);\n\t},\n\tgetSearchListTokenId(paginationParams: ListParams, filter: ListParams): Promise<any> {\n\t\tconst { pageSize, page } = paginationParams;\n\n\t\tconst url = `/items/query-search/pageSize/${pageSize}/page/${page}`;\n\t\tconst body = { ...filter };\n\t\treturn axiosClient.post(url, body);\n\t},\n\tgetLessNftInfoByTokenId(filter: ListParams): Promise<any> {\n\t\tconst { itemId, userAddress } = filter;\n\t\tconst url = `/items/itemId/${itemId}?userAddress=${userAddress}`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetDetailNftItemById(itemId: string): Promise<any> {\n\t\tconst url = `/items/detail/itemId/${itemId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetSearchNftItemById(itemId: string): Promise<any> {\n\t\tconst url = `/items/search/itemId/${itemId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetDataForFreezeNft(itemId: string): Promise<any> {\n\t\tconst url = `/items/freeze/metadata/itemId/${itemId}`;\n\t\treturn axiosClient.get(url);\n\t},\n};\n\nexport default nftsApi;\n","import { OfferFilter } from 'models';\nimport axiosAuthen from './axiosAuthen';\nimport axiosClient from './axiosClient';\n\nconst orderApi = {\n\t//AUTHENTICATE\n\tcreateOrder(data: any, chainId: number): Promise<any> {\n\t\tconsole.log('data gui len ne', { ...data, chainId });\n\n\t\tconst url = `/sell/create`;\n\t\treturn axiosAuthen.post(url, { ...data, chainId });\n\t},\n\tacceptOrder(data: any): Promise<any> {\n\t\tconst { order, collectionId, chainId, transactionHash, type, finalPrice, userAddress } =\n\t\t\tdata;\n\t\tconst url = `buy/create`;\n\t\tconsole.log('data gui len ne', {\n\t\t\t...order,\n\t\t\tcollectionId,\n\t\t\ttransactionHash,\n\t\t\ttype,\n\t\t\tfinalPrice,\n\t\t\tuserAddress,\n\t\t\tchainId,\n\t\t});\n\n\t\treturn axiosAuthen.post(url, {\n\t\t\t...order,\n\t\t\tcollectionId,\n\t\t\ttransactionHash,\n\t\t\ttype,\n\t\t\tfinalPrice,\n\t\t\tuserAddress,\n\t\t\tchainId,\n\t\t});\n\t},\n\n\tdeleteOrder(data: any): Promise<any> {\n\t\tconsole.log('data gui len ne', data);\n\n\t\tconst url = `orders/delete`;\n\t\treturn axiosAuthen.post(url, data);\n\t},\n\n\t//CLIENT\n\tgetOrderDetailByUser(orderId: string): Promise<any> {\n\t\tconst url = `/offers/user/orderId/${orderId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\n\tgetOrderDetail(orderId: string): Promise<any> {\n\t\tconst url = `/orders/detail/orderId/${orderId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\n\tgetOrderSellByItemId(itemId: string): Promise<any> {\n\t\tconst url = `orders/itemId/${itemId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\n\tgetPersonalOffer(userAddress: string, itemId: string): Promise<any> {\n\t\tconst url = `offers/userAddress/${userAddress}/itemId/${itemId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\n\tgetListOffer(filter: OfferFilter): Promise<any> {\n\t\tconst url = `offers/query`;\n\t\treturn axiosClient.post(url, filter);\n\t},\n};\n\nexport default orderApi;\n","import axiosClient from './axiosClient';\n\nconst tokenPaymentApi = {\n\tgetListPaymentTokenByChainId(chainId: number): Promise<any> {\n\t\tconst url = `orders/listToken?chainId=${chainId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\n\tchangeTokenToUsd(from: string, to: string, inputPrice: string): Promise<any> {\n\t\tconst url = `/items/changePrice`;\n\t\treturn axiosClient.post(url, { from, to, inputPrice });\n\t},\n};\n\nexport default tokenPaymentApi;\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport tokenPaymentApi from 'apis/tokenPaymentApi';\nimport { ListResponseNonPaging, TokenPayment } from 'models';\nimport {\n\tstartLoading,\n\thasError,\n\tfetchListTokenPaymentSuccess,\n} from 'redux/slices/tokenPaymentSlice';\nimport { dispatch, getState } from '../store';\n\nexport function fetchListPaymentTokenByChainId(chainId: number, MyCallBack?: Function) {\n\treturn async () => {\n\t\tdispatch(startLoading());\n\t\ttry {\n\t\t\tconst response: ListResponseNonPaging<TokenPayment> =\n\t\t\t\tawait tokenPaymentApi.getListPaymentTokenByChainId(chainId);\n\t\t\tdispatch(fetchListTokenPaymentSuccess(response));\n\t\t} catch (error) {\n\t\t\tdispatch(hasError(error));\n\t\t\tif (MyCallBack) MyCallBack(getState());\n\t\t}\n\t};\n}\n","import { ListParams, ListResponse, UserActivity, PriceActivity, CollectionActivity } from 'models';\nimport axiosClient from './axiosClient';\n\nconst tradingApi = {\n\tgetTradingHistoryByNFTsId(data: ListParams): Promise<any> {\n\t\tconst { itemId } = data;\n\t\tconst url = `/histories/itemId/${itemId}/pageSize/9999/page/1`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetActivityHistoryByUserAddress(userAddress: string): Promise<ListResponse<UserActivity>> {\n\t\tconst url = `/histories/userAddress/${userAddress}/pageSize/9999/page/1`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetActivityHistoryByCollectionId(\n\t\tcollectionId: string\n\t): Promise<ListResponse<CollectionActivity>> {\n\t\tconst url = `/histories/collectionId/${collectionId}/pageSize/9999/page/1`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetActivityPriceChart(itemId: string): Promise<PriceActivity[]> {\n\t\tconst url = `/histories/chart/itemId/${itemId}`;\n\t\treturn axiosClient.get(url);\n\t},\n\tgetLatestTransaction(): Promise<any> {\n\t\tconst url = `/histories/latest`;\n\t\treturn axiosClient.get(url);\n\t},\n};\n\nexport default tradingApi;\n","import { ListParams } from 'models';\nimport { dispatch, getState } from '../store';\nimport tradingApi from 'apis/historyApi';\nimport {\n\tstartLoading,\n\thasError,\n\tfetchTradingHistorySuccess,\n\tfetchUserHistorySuccess,\n\tfetchCollectionHistorySuccess,\n} from 'redux/slices/tradingSlice';\nimport { ItemActivity } from 'models';\n\nexport function fetchTradingHistoryByNFTsId(data: ListParams, MyCallBack?: Function) {\n\treturn async () => {\n\t\tdispatch(startLoading());\n\t\ttry {\n\t\t\tconst response: ItemActivity[] = await tradingApi.getTradingHistoryByNFTsId(data);\n\n\t\t\tdispatch(fetchTradingHistorySuccess(response));\n\t\t} catch (error) {\n\t\t\tdispatch(hasError(error));\n\t\t} finally {\n\t\t\tif (MyCallBack) MyCallBack(getState());\n\t\t}\n\t};\n}\n\nexport function fetchUserHistory(userAddress: string, MyCallBack?: Function) {\n\treturn async () => {\n\t\tdispatch(startLoading());\n\t\ttry {\n\t\t\tconst response = await tradingApi.getActivityHistoryByUserAddress(userAddress);\n\t\t\tdispatch(fetchUserHistorySuccess(response));\n\t\t} catch (error) {\n\t\t\tdispatch(hasError(error));\n\t\t} finally {\n\t\t\tif (MyCallBack) MyCallBack(getState());\n\t\t}\n\t};\n}\n\nexport function fetchCollectionHistory(collectionId: string, MyCallBack?: Function) {\n\treturn async () => {\n\t\tdispatch(startLoading());\n\t\ttry {\n\t\t\tconst response = await tradingApi.getActivityHistoryByCollectionId(collectionId);\n\t\t\tdispatch(fetchCollectionHistorySuccess(response));\n\t\t} catch (error) {\n\t\t\tdispatch(hasError(error));\n\t\t} finally {\n\t\t\tif (MyCallBack) MyCallBack(getState());\n\t\t}\n\t};\n}\n","import nftsApi from 'apis/nftsApi';\nimport { NFT, Response } from 'models';\nimport { startLoading, hasError, fetchNftItemSuccess } from 'redux/slices/nftItemByItemIdSlice';\n\nexport function fetchDetailNftItemById(itemId: string, MyCallBack: (value: any) => void) {\n\treturn async (dispatch: any, getState: any) => {\n\t\tdispatch(startLoading());\n\t\ttry {\n\t\t\tconst response: Response<NFT> = await nftsApi.getDetailNftItemById(itemId);\n\t\t\tdispatch(fetchNftItemSuccess(response));\n\t\t} catch (error) {\n\t\t\tdispatch(hasError(error));\n\t\t} finally {\n\t\t\tif (MyCallBack) MyCallBack(getState());\n\t\t}\n\t};\n}\n","import orderApi from 'apis/orderApi';\nimport { OrderResponseAPI, ListResponse, ListParams } from 'models';\nimport { getListOrderOfferSuccess, hasError, startLoading } from 'redux/slices/orderSlice';\nimport { dispatch, getState } from '../store';\n\nexport function fetchListOrderOffer(filter: ListParams, MyCallBack?: Function) {\n\treturn async () => {\n\t\tdispatch(startLoading());\n\t\ttry {\n\t\t\tconst response: ListResponse<OrderResponseAPI> = await orderApi.getListOffer(filter);\n\n\t\t\tdispatch(getListOrderOfferSuccess(response));\n\t\t} catch (error) {\n\t\t\tdispatch(hasError(error));\n\t\t} finally {\n\t\t\tif (MyCallBack) MyCallBack(getState());\n\t\t}\n\t};\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport React, { lazy, useEffect, useState } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { toast } from 'react-toastify';\n// redux\nimport { RootState } from 'redux/store';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { selectLoading } from 'redux/slices/nftItemByItemIdSlice';\nimport { selectNftItem } from 'redux/slices/nftItemByItemIdSlice';\nimport { selectChainId, selectAddress } from 'redux/slices/web3InfoSlice';\nimport { selectFilter } from 'redux/slices/orderSlice';\n//actions\nimport { fetchDetailNftItemById } from 'redux/actions/nftItemByItemIdAction';\nimport { fetchListPaymentTokenByChainId } from 'redux/actions/tokenPaymentAction';\nimport { fetchListOrderOffer } from 'redux/actions/orderAction';\nimport { fetchTradingHistoryByNFTsId } from 'redux/actions/tradingAction';\n// models\nimport { NFT, OrderResponseAPI, PriceActivity } from 'models';\n// mui\nimport { Container, Grid, Box } from '@mui/material';\n// api\nimport orderApi from 'apis/orderApi';\nimport historyApi from 'apis/historyApi';\n// components\nimport Loadable from 'components/CustomUI/LoadableComponent';\n// utils\nimport { compareDate, timestampToDate } from 'utils';\n// constants\nimport { ORDER_TYPE } from '../../constants';\n\nconst TradingHistory = Loadable(lazy(() => import('components/pages/ItemDetail/TradingHistory')));\nconst ItemImage = Loadable(lazy(() => import('components/pages/ItemDetail/ItemImage')));\nconst MoreItem = Loadable(lazy(() => import('components/pages/ItemDetail/MoreItem')));\nconst TabItemDetail = Loadable(lazy(() => import('components/pages/ItemDetail/TabItemDetail')));\nconst Loading = Loadable(lazy(() => import('components/CustomUI/LoadingPage')));\n\ndeclare let window: any;\n\nconst Detail = () => {\n\tconst { itemId } = useParams();\n\tconst dispatch = useDispatch();\n\n\t//state\n\tconst [listActivityPriceChart, setListActivityPriceChart] = useState<PriceActivity[]>([]);\n\tconst [personalOffer, setPersonalOffer] = useState<OrderResponseAPI | null>(null);\n\tconst [isLoadingPersonalOffer, setIsLoadingPersonalOffer] = useState<boolean>(false);\n\tconst [isDeletingOrderExpired, setIsDeletingOrderExpired] = useState<boolean>(false);\n\tconst [stateRefetchApi, setStateRefetchApi] = useState<boolean>(false);\n\n\t//selector\n\tconst item: NFT | null = useSelector(selectNftItem);\n\tconst chainId = useSelector(selectChainId);\n\tconst isLoadingItem = useSelector(selectLoading);\n\tconst filter = useSelector(selectFilter);\n\tconst addressState = useSelector(selectAddress);\n\n\t//useEffect\n\t// fetch NFT detail\n\tuseEffect(() => {\n\t\tif (itemId) dispatch(fetchDetailNftItemById(itemId, executeAfterFetchNftItemById));\n\n\t\twindow.scrollTo({ top: 0, behavior: 'smooth' });\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [stateRefetchApi, itemId]);\n\n\t// fetch list payment token\n\tuseEffect(() => {\n\t\tif (chainId) {\n\t\t\tdispatch(fetchListPaymentTokenByChainId(chainId, executeAfterFetchListTokenPayment));\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [chainId]);\n\n\t// fetch list order offer\n\tuseEffect(() => {\n\t\tif (chainId && itemId) {\n\t\t\tdispatch(fetchListOrderOffer({ itemId, ...filter }, executeAfterFetchListOrderOffer));\n\t\t}\n\t}, [dispatch, chainId, filter, stateRefetchApi, itemId]);\n\n\t//fetch personal order offer\n\tuseEffect(() => {\n\t\tif (addressState && itemId) {\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tsetIsLoadingPersonalOffer(true);\n\t\t\t\t\tconst offerRes: OrderResponseAPI = await orderApi.getPersonalOffer(\n\t\t\t\t\t\taddressState,\n\t\t\t\t\t\titemId\n\t\t\t\t\t);\n\n\t\t\t\t\tsetPersonalOffer(offerRes);\n\t\t\t\t} catch (error: any) {\n\t\t\t\t\tsetPersonalOffer(null);\n\t\t\t\t\tconsole.log(error.message);\n\t\t\t\t} finally {\n\t\t\t\t\tsetIsLoadingPersonalOffer(false);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t}, [addressState, itemId, stateRefetchApi]);\n\n\t// fetch activity price chart\n\tuseEffect(() => {\n\t\tif (itemId) {\n\t\t\t(async function () {\n\t\t\t\ttry {\n\t\t\t\t\tconst response: PriceActivity[] = await historyApi.getActivityPriceChart(\n\t\t\t\t\t\titemId\n\t\t\t\t\t);\n\n\t\t\t\t\tsetListActivityPriceChart(response);\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tconsole.log(e);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t}, [dispatch, stateRefetchApi, itemId]);\n\n\t// fetch history of the item\n\tuseEffect(() => {\n\t\tif (chainId) {\n\t\t\tdispatch(\n\t\t\t\tfetchTradingHistoryByNFTsId({ chainId, itemId }, executeAfterFetchHistoryOfItem)\n\t\t\t);\n\t\t}\n\t}, [dispatch, itemId, chainId, stateRefetchApi, itemId]);\n\n\t//function\n\tconst refetchApi = () => {\n\t\tsetStateRefetchApi(!stateRefetchApi);\n\t};\n\n\tconst executeAfterFetchNftItemById = async (globalStateNewest: RootState) => {\n\t\tconst { nftItem } = globalStateNewest;\n\n\t\tif (!nftItem.isSuccess) {\n\t\t\ttoast.error(nftItem.errorMessage, {\n\t\t\t\tautoClose: 2500,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// check expire order sell\n\t\tconst orderSell: OrderResponseAPI | undefined = nftItem.NFTItem!.order;\n\t\tif (\n\t\t\torderSell &&\n\t\t\tcompareDate(new Date(), timestampToDate(parseInt(orderSell.expirationTime))) > 0\n\t\t) {\n\t\t\ttry {\n\t\t\t\tsetIsDeletingOrderExpired(true);\n\t\t\t\t// call api delete order sell and save a history record on database\n\t\t\t\tconst collectionId = nftItem.NFTItem!.collection?.collectionId;\n\n\t\t\t\tconst deleteData = {\n\t\t\t\t\tcollectionId,\n\t\t\t\t\torderId: orderSell.orderId ?? orderSell._id,\n\t\t\t\t\ttype: ORDER_TYPE.EXPIRED_LISTING,\n\t\t\t\t\ttransactionHash: '',\n\t\t\t\t};\n\n\t\t\t\tawait orderApi.deleteOrder(deleteData);\n\n\t\t\t\trefetchApi();\n\t\t\t} catch (error) {\n\t\t\t\ttoast.error('Some error occur when executing your expired order sell!');\n\t\t\t} finally {\n\t\t\t\tsetIsDeletingOrderExpired(false);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst executeAfterFetchListTokenPayment = (globalStateNewest: RootState) => {\n\t\tconst { tokenPayment } = globalStateNewest;\n\t\tif (!tokenPayment.isSuccess) {\n\t\t\ttoast.error('Can not fetch list token payment!');\n\t\t}\n\t};\n\n\tconst executeAfterFetchListOrderOffer = (globalStateNewest: RootState) => {\n\t\tconst { order } = globalStateNewest;\n\t\tif (!order.isSuccess) {\n\t\t\ttoast.error('Can not fetch order offer of this item!');\n\t\t}\n\t};\n\n\tconst executeAfterFetchHistoryOfItem = (globalStateNewest: RootState) => {\n\t\tconst { tradeHistory } = globalStateNewest;\n\t\tif (!tradeHistory.isSuccess) {\n\t\t\ttoast.error('Can not fetch histories of this item!');\n\t\t}\n\t};\n\n\treturn (\n\t\t<>\n\t\t\t{isLoadingItem || isDeletingOrderExpired ? (\n\t\t\t\t<Loading />\n\t\t\t) : (\n\t\t\t\t<Container maxWidth=\"xl\" sx={{ mt: 5 }}>\n\t\t\t\t\t<Grid container spacing={10}>\n\t\t\t\t\t\t<Grid item xs={12} lg={6}>\n\t\t\t\t\t\t\t<ItemImage item={item} />\n\t\t\t\t\t\t</Grid>\n\t\t\t\t\t\t<Grid item xs={12} lg={6}>\n\t\t\t\t\t\t\t<TabItemDetail\n\t\t\t\t\t\t\t\t// props for ItemInfoTab\n\t\t\t\t\t\t\t\titem={item}\n\t\t\t\t\t\t\t\tpersonalOffer={personalOffer}\n\t\t\t\t\t\t\t\tloadingPersonalOffer={isLoadingPersonalOffer}\n\t\t\t\t\t\t\t\trefetchApi={refetchApi}\n\t\t\t\t\t\t\t\t// props for GraphTab\n\t\t\t\t\t\t\t\tlistActivityPriceChart={listActivityPriceChart}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</Grid>\n\t\t\t\t\t</Grid>\n\n\t\t\t\t\t{item && (\n\t\t\t\t\t\t<Box sx={{ mt: 5 }}>\n\t\t\t\t\t\t\t<TradingHistory />\n\t\t\t\t\t\t</Box>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{itemId && (\n\t\t\t\t\t\t<Box sx={{ mt: 5 }}>\n\t\t\t\t\t\t\t<MoreItem collection={item?.collection} itemId={itemId} />\n\t\t\t\t\t\t</Box>\n\t\t\t\t\t)}\n\t\t\t\t</Container>\n\t\t\t)}\n\t\t</>\n\t);\n};\n\nexport default Detail;\n"],"sourceRoot":""}